---
title: "2-2: Assignment 1 Review and Coordinate Reference Systems"
author: "Zach"
date: "2020-08-31"
output: html_document
---
    
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview
This week we will go over the script that we developed last session.  We will address some
of the questions from last week's assignment and go over the projection issue encountered
in the toy data set.  Let's dive in!


---

## Today's Assignment -- Looking at North Carolina County Data: Part II

### You will need:
* **The script you wrote last week**
* **Post-work beverage of choice**

### Part 1:  Script and Questions Review

* Open RStudio

* Open up the script you wrote last session via one of the two methods:
    * Click on `File > Open File`
    * Press `ctrl + O`
    
    and then navigate to the folder where you saved your script.
    
    
Your script should look something like the following.  Notice that I've commented out
the line that installs all of the packages, as that only needs to be completed once (and
you probably did that last week).  Additionally, I've set the CRS for the dataset based
on some digging online.  We'll get into that a bit later.

```{r last-week-script, eval=FALSE}

# ---------------------------------------------------------------------------------------
#  Part 1
# ---------------------------------------------------------------------------------------
# Installs all the packages necessary for this assignment.  Only needs to be run once.
# install.packages(c('magrittr', 'data.table', 'sf', 'dplyr', 'maptools', 'mapview'))  

# Import libraries to utilize their functions
library(magrittr)   # pipe functions into one another ('%>%' symbol)
library(data.table) # fast manipulation of data in table format (think Excel spreadsheets)
library(dplyr)      # more data manipulation functions
library(sf)         # geospatial functions
library(maptools)   # contains our toy data set
library(mapview)    # An alternative to plot() for plotting spatial data


# Obtain file path of our toy dataset
toy.data.file <- system.file('shapes/sids.shp', package="maptools")

# Read in shapefile 
nc.county.boundaries <- st_read(toy.data.file)

nc.county.boundaries  # Look at full dataset
nc.county.boundaries$AREA  # Look at the AREA column only

# Visualize output
plot(nc.county.boundaries)

mapview(nc.county.boundaries)


# ---------------------------------------------------------------------------------------
#  Part 2
# ---------------------------------------------------------------------------------------
# Notice that the data do not come set with a coordinate reference system (CRS).
# Leaflet, (the mapping framework used by mapview) requires CRS the to be 4326 to
# geospatially reference the data.  So we will need to define a CRS and project our
# data appropriately.
st_crs(nc.county.boundaries)

# Set the CRS  
st_crs(nc.county.boundaries) <- 4267

# View the CRS
st_crs(nc.county.boundaries)

# Project data to the new CRS  
nc.county.boundaries <- st_transform(nc.county.boundaries, 4326)

# View the new CRS
st_crs(nc.county.boundaries)

# Union all geometries together
st_union(nc.county.boundaries) %>% mapview(col.regions='red')

# Union all geometries together, then buffer by 0.1 arc degrees (final shape is larger 
# than the original)
st_union(nc.county.boundaries) %>% st_buffer(0.1) %>% mapview(col.regions='blue')

# Union all geometries together, then buffer by -0.1 arc degrees (final shape is smaller 
# than the original)
st_union(nc.county.boundaries) %>% st_buffer(-0.1) %>% mapview(col.regions='green')

# Show effects of union and buffering on combined plot
mapview(st_union(nc.county.boundaries) %>% st_buffer(0.1), col.regions='blue') +
    mapview(nc.county.boundaries, col.regions='red') +
    mapview(st_union(nc.county.boundaries) %>% st_buffer(-0.1), col.regions='green')

# What does this do?
nc.county.boundaries %>% group_by() %>% summarize
```


Let's review the questions from session 1.

1. *Part 1 Questions* 

    a.  What are some differences and similarities between the map generated by `plot()` 
    vs. the map generated by `mapview()`?
    
    b.  For the map generated by `mapview()`, click on a shape.  What happens?
    
    c.  For the map generated by `mapview()`, click on a shape and count the number of 
    attributes.  What do these attributes represent in the variable 
    `nc.county.boundaries`?  With this information, what do you think the warning message 
    generated by the `plot()` command means?
    
    d.  Which plotting method do you prefer, and why?
    
    e.  CHALLENGE: For the map generated by `plot()`, why do the colors for some of the 
    fields look more like a continuous gradient (e.g. `CNTY_`, `CNTY_ID`), while others 
    look more discrete, or separate (e.g. `NAME`, `FIPS`).  **HINT**: consider the *type* 
    of variable in those columns.


2. *Part 2 Questions*

    a.  What geospatial operation is executed by the final line: 
    `nc.county.boundaries %>% group_by() %>% summarize`?  To answer this, it may be 
    helpful to plot the result.

    b.  Read about how to get, set, and transform CRS's by executing `?st_crs`.
    You can access help documentation for any function by prefixing the function name with
    a `?`.
    
    c.  Read up on the philosophy behind the `sf` 
    package [**here**](https://r-spatial.github.io/sf/articles/sf1.html).  Use 
    `methods(class="sf")` to see more options for geospatial operations.  Try out a few
    that we haven't covered here.

    d.  Try generating the maps above using the `plot()` command instead of `mapview()`.
    To prevent `plot()` from generating individual plots for every column in
    `nc.county.boundaries`, you'll need to subset the data.  Run the command 
    `plot(nc.county.boundaries[, c('NAME', 'geometry')])` to get a single plot of the
    `NAME` column.  Now, try plotting other columns.  What happens when you add or remove
    column names to the `c()` list?
    
---
    
### Part 2:  Coordinate Reference Systems

```{r set-vars, warning=FALSE, echo=FALSE, message=FALSE}
library(magrittr) 
library(data.table) 
library(dplyr)     
library(sf)        
library(maptools)  
library(mapview)   


# Obtain file path of our toy dataset
toy.data.file <- system.file('shapes/sids.shp', package="maptools")

# Read in shapefile 
nc.county.boundaries <- st_read(toy.data.file, quiet=TRUE)
```

Let's return to the missing CRS issue in the example data.  Why is it such a big deal
that there is no CRS associated with the dataset?  Put simply, coordinate
reference systems relate spatial data to locations on earth, so without a CRS we cannot 
reliably georeference our data.  

CRS's come in two flavors:  geographic and projected.
Both relate spatial coordinates to locations on the Earth.  A geographic CRS is 
defined by an ellipsoid which specifies locations in terms of 3-dimensional coordinates 
(i.e. latitude and longitude).  A projected CRS is derived from a geographic CRS, as it is
a 2-dimensional projection of the 3-D, geographic CRS.  Distances in projected coordinate
systems are defined by linear units such feet and meters.

After looking through the `maptools` documentation, I found that the maintainers of the
package specify the datum as `NAD27`.  For those familiar with datums, you may recognize
this as the North American Datum of 1927 (EPSG:4267).  This is an older datum, and a more
up-to-date one for North America is NAD83 (EPSG:4269).  The big difference here is that
the 1983 datum is substantially more accurate than its counterpart from 1927, since it 
leverages much more dense and precise data (e.g. from GPS satellites) and is based on a
more accurate ellipsoid (GRS80 for NAD83, Clrk66 for NAD27).  There's a lot to datums, 
CRS's and the like, so I encourage you to read up on it on your own and in some of the 
links that I have provided.

#### What's this EPSG business?
An EPSG code is a way to reference a particular CRS.  A CRS has a lot of information 
associated with it, and the EPSG identifier consisely wraps it up into a 4 or 5 digit 
code.  We can use `st_crs()` to see the EPSG identifier for a dataset.

```{r crs-investigation-1}
# Dataset as it came in originally
st_crs(nc.county.boundaries)

# Set the CRS
st_crs(nc.county.boundaries) <- 4267

# View the CRS
st_crs(nc.county.boundaries)
```

A handy way to check if the CRS you're using is geographic or projected is to look at the 
third line of the output of the `st_crs` command.  Notice that a projected coordinate
system (e.g. Web Mercator, EPSG:3857) will have a line telling you the base geographic CRS
from which it is projected.

```{r crs-investigation-2}
# Check out the 3rd and 4th lines in the following output.  Incidentally, this is a nice 
# example of what the %>% operator can do
nc.county.boundaries %>% st_transform(3857) %>% st_crs
```

#### What's the effect of changing CRS's?
A coordinate reference system defines a location on Earth, so changing the reference 
system will change the location on the Earth that the coordinates reference.  We can check
the extent of the shape, or the bounding box, to see how it changes based on the CRS we 
use.

```{r crs-investigation-3, warning=FALSE, message=FALSE}
# Let's transform the NC data to 4269, which uses the NAD83 datum.
nc.county.boundaries.83 <- st_transform(nc.county.boundaries, 4269)
# st_crs(nc.county.boundaries.83)

# For kicks, let's also transform to 4326, which uses the WGS84 datum.  This is a common 
# global CRS.
nc.county.boundaries.84 <- st_transform(nc.county.boundaries, 4326)
# st_crs(nc.county.boundaries.84)

# Union the geometries so we're only working with a single shape
nc.county.boundaries    <- st_union(nc.county.boundaries)    # EPSG: 4267 ; Datum: NAD27
nc.county.boundaries.83 <- st_union(nc.county.boundaries.83) # EPSG: 4269 ; Datum: NAD83
nc.county.boundaries.84 <- st_union(nc.county.boundaries.84) # EPSG: 4326 ; Datum: WGS84

# Use st_bbox() to get the bounding boxes of the (now-unioned) shapes
st_bbox(nc.county.boundaries)
st_bbox(nc.county.boundaries.83)
st_bbox(nc.county.boundaries.84)

# Write these out to files so we can look at them in a GIS
out.path <- file.path(Sys.getenv('HOME'), 'QGIS')

st_write(nc.county.boundaries, file.path(out.path, 'NC_data_NAD27.gpkg'), 
         delete_dsn=TRUE, quiet = TRUE)
st_write(nc.county.boundaries.83, file.path(out.path, 'NC_data_NAD83.gpkg'), 
         delete_dsn=TRUE, quiet = TRUE)
st_write(nc.county.boundaries.84, file.path(out.path, 'NC_data_WGS84.gpkg'), 
         delete_dsn=TRUE, quiet = TRUE)

```
    
A couple of things to note here: 

* In the spirit of keeping our software open source, I'm using the `geopackage` driver to
write out our shapefiles.  You can visualize a geopackage in QGIS just like a shapefile.

* To write out the files like I have, run `Sys.getenv('HOME')` to see where the home
directory on your machine is.  Navigate there and then add a folder called `QGIS`.  Then
the geopackages should be written there.

* Why do the bounding boxes and shapes seem identical for the data in NAD83 and WGS84?

* These are all geographic coordinate systems, with bounding box extents measured in 
latitude and longitude.  What do you think the extents would look like if we ran `st_bbox`
on data in a projected coordinate system?  *Hint*: how are distances measured in projected
CRS's vs in geographic CRS's?

* I didn't realize this until later, but there is an identical North Carolina example
dataset that actually has its CRS set.  This is one of the ways that I confirmed the data 
were supposed to be in 4267.  You can import it from the built-in `nc.shape` file.

```{r nc-data-good}
st_read(system.file("shape/nc.shp", package='sf'), quiet=TRUE) %>% st_crs
```
  
### Wrap-Up  
Check out the links below to learn more about working with geospatial data in R.  If you 
want a challenge, check out the online textbook in the third link and work through some of
the chapters and exercises.

---

## Further Reading

* [**An introduction to geodetic datums**](https://gisgeography.com/geodetic-datums-nad27-nad83-wgs84/)
* [**Searchable database of EPSG identifiers**](https://epsg.io/).
* [**Web portal for EPSG identifiers**](https://spatialreference.org/)
* [**Chapter 2**](https://geocompr.robinlovelace.net/spatial-class.html) from the
geographic computation in R text I linked to last week.  If you have time, read through 
this chapter [**and chapter 6**](https://geocompr.robinlovelace.net/reproj-geo-data.html).
Section 2.4 has a good primer on CRS's, and chapter 6 dives into transformations between CRS's.  Try some of the exercises at the end of the chapters.